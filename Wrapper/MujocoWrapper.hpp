//----------------------------------------------------------------------------------------------------
// File: MujocoWrapper.hpp
// Desc: wrapper class for interfacing with MuJoCo
//----------------------------------------------------------------------------------------------------
#pragma once

// Standard libraries includes
#include <string>
#include <array>
#include <utility>
#include <iostream>

// Third-party dependencies
#include <mujoco/mujoco.h>

// Project-specific
#include "../Core/Models/DynamicsBase.hpp"

namespace gtfo{

template<unsigned int Dimensions>
class MujocoWrapper : public DynamicsBase<Dimensions, mjtNum>{
public:
    using Base = DynamicsBase<Dimensions, mjtNum>;
    using VectorN = Eigen::Matrix<mjtNum, Dimensions, 1>;

    MujocoWrapper(const std::string& model_file, const mjtNum& timestep)
        :   Base(),
            model_(nullptr),
            data_(nullptr)
    {
        // Ensure header and compiled library versions match
        assert(mjVERSION_HEADER == mj_version());

        assert(timestep > 0.0);

        // Parse and compile the model from file
        // TODO: update this to load a precompiled MJB file, which gets generated by cmake
        std::array<char, 1000> error;
        model_ = mj_loadXML(model_file.c_str(), NULL, error.data(), 1000);
        if(!model_){
            mju_error("Could not load model from file");
        }

        // Ensure the dimensions of the model state and control match up
        if(Dimensions != model_->nv){
            mju_error("Dimensions of Wrapper and MuJoCo model state are mismatched");
        }
        if(model_->nv != model_->nu){
            mju_error("Dimensions of MuJoCo model state and control are mismatched");
        }

        // Set simultation parameters
        model_->opt.timestep = timestep;

        data_ = mj_makeData(model_);

        std::cout << "Constructor called\n";
    }

    // Enables the copy-and-swap idiom
    friend void swap(MujocoWrapper& first, MujocoWrapper& second) noexcept{
        using std::swap;
        swap(static_cast<Base&>(first), static_cast<Base&>(second));
        swap(first.model_, second.model_);
        swap(first.data_, second.data_);

        std::cout << "    Swap called\n";
    }

    // Copy constructor
    MujocoWrapper(const MujocoWrapper& other)
        :   Base(other),
            model_(nullptr),
            data_(nullptr)
    {
        mj_copyModel(model_, other.model_);
        mj_copyData(data_, other.model_, other.data_);
        std::cout << "Copy constructor called\n";
    }

    // Move constructor
    MujocoWrapper(MujocoWrapper&& other) noexcept
        :   Base(),
            model_(nullptr),
            data_(nullptr)
    {
        swap(*this, other);
        std::cout << "Move constructor called\n";
    }

    // Assignment operator
    MujocoWrapper& operator=(MujocoWrapper other){
        swap(*this, other); 
        return *this;
        std::cout << "Assignment operator called\n";
    }

    // Destructor
    ~MujocoWrapper(){
        mj_deleteModel(model_);
        mj_deleteData(data_);
        std::cout << "Destructor called\n";
    }

    bool Step(const VectorN& force_input, const VectorN& physical_position = VectorN::Constant(NAN)) override{
        // Update the virtual position if a physical position is given
        const bool err = this->SyncVirtualPositionToPhysical(physical_position);
        VectorN::Map(data_->qpos) = Base::position_;

        // Compute all intermediate results dependent on the state, but not the control
        // Note that by using mj_step1 and mj_step2, the integrator must be the default Euler
        mj_step1(model_, data_);

        // Update the state variables
        Base::position_ = VectorN::Map(data_->qpos);
        Base::velocity_ = VectorN::Map(data_->qvel);
        const VectorN previous_velocity = VectorN::Map(data_->qvel);

        // Apply the control
        VectorN::Map(data_->ctrl) = force_input + this->EnforceSoftBound();

        // Finish computing results that depend on the control input
        mj_step2(model_, data_);

        // Restrict and set the position and velocity after the integration timestep
        this->EnforceHardBound();
        VectorN::Map(data_->qpos) = Base::position_;
        VectorN::Map(data_->qvel) = Base::velocity_;

        // Update the acceleration with a backward difference
        Base::acceleration_ = (Base::velocity_ - previous_velocity) / model_->opt.timestep;

        return err;
    }

private:
    mjModel* model_;
    mjData* data_;
};

} // namespace gtfo