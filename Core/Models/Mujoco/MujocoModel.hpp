//----------------------------------------------------------------------------------------------------
// File: MujocoModel.hpp
// Desc: wrapper class for interfacing with MuJoCo
//----------------------------------------------------------------------------------------------------
#pragma once

// Standard libraries includes
#include <string>
#include <array>

// Third-party dependencies
#include <mujoco/mujoco.h>

// Project-specific
#include "../DynamicsBase.hpp"

namespace gtfo{

template<unsigned int Dimensions, typename Scalar = double>
class MujocoModel : public DynamicsBase<Dimensions, Scalar>{
public:
    using Base = DynamicsBase<Dimensions, Scalar>;
    using VectorN = Eigen::Matrix<Scalar, Dimensions, 1>;
    using MujocoVectorN = Eigen::Matrix<mjtNum, Dimensions, 1>;

    // group_id should match the group field for each joint in the XML
    MujocoModel(const std::string& model_file, const int& group_id, const Scalar& timestep, const VectorN& initial_position = VectorN::Zero())
        :   Base(initial_position),
            model_(nullptr),
            data_(nullptr)
    {
        // Ensure header and compiled library versions match
        assert(mjVERSION_HEADER == mj_version());

        assert(timestep > 0.0);

        // Parse and compile the model from file
        // TODO: update this to load a precompiled MJB file, which gets generated by cmake
        std::array<char, 1000> error;
        model_ = mj_loadXML(model_file.c_str(), NULL, error.data(), 1000);
        if(!model_){
            mju_error("Could not load model from file");
        }

        // MujocoModel requires the relevant joints in mjModel to be 1D, since then the dimensions of position and velocity are equal
        for(int i = 0; i < model_->njnt; ++i){
            if(model_->jnt_group[i] == group_id && model_->jnt_type[i] != mjJNT_SLIDE && model_->jnt_type[i] != mjJNT_HINGE){
                mju_error("MujocoModel requires the corresponding joints in mjModel to be of type slide or hinge");
            }
        }

        // Check that the number of relevant joints matches the Dimension
        size_t num_relevant_joints = 0;
        for(int i = 0; i < model_->njnt; ++i){
            if(model_->jnt_group[i] == group_id){
                num_relevant_joints ++;
            }
        }
        if(num_relevant_joints != Dimensions){
            mju_error("Dimensions of MujocoModel is different from the number of relevant joints in mjModel");
        }

        // Require that there are only as many actuators as the Dimension
        if(model_->nu != Dimensions){
            mju_error("Dimensions of MujocoModel is different from the number of actuators in mjModel");
        }

        // Get the addresses of the relevant positions and velocities
        size_t dimension_index = 0;
        for(int i = 0; i < model_->njnt; ++i){
            if(model_->jnt_group[i] == group_id){
                position_offsets_[dimension_index] = model_->jnt_qposadr[i];
                velocity_offsets_[dimension_index] = model_->jnt_dofadr[i];
                dimension_index++;
            }
        }

        // Set simultation parameters
        model_->opt.timestep = timestep;

        data_ = mj_makeData(model_);

        // Set the initial position
        for(size_t i = 0; i < Dimensions; ++i){
            *(data_->qpos + position_offsets_[i]) = static_cast<mjtNum>(Base::position_[i]);
        }
    }

    // Copy constructor
    MujocoModel(const MujocoModel& other)
        :   Base(other)
    {
        model_ = mj_copyModel(nullptr, other.model_);
        data_ = mj_copyData(nullptr, other.model_, other.data_);
        position_offsets_ = other.position_offsets_;
        velocity_offsets_ = other.velocity_offsets_;
    }

    // Move constructor
    MujocoModel(MujocoModel&& other) noexcept
        :   Base(other)
    {
        model_ = other.model_;
        data_ = other.data_;
        position_offsets_ = other.position_offsets_;
        velocity_offsets_ = other.velocity_offsets_;
        other.model_ = nullptr;
        other.data_ = nullptr;
    }

    // Assignment operator
    MujocoModel& operator=(const MujocoModel& other){
        // Check against self-assignment
        if(this == &other){
            return *this;
        }

        mj_deleteModel(model_);
        mj_deleteData(data_);
        
        model_ = mj_copyModel(nullptr, other.model_);
        data_ = mj_copyData(nullptr, other.model_, other.data_);  
        position_offsets_ = other.position_offsets_;
        velocity_offsets_ = other.velocity_offsets_;

        return *this;
    }

    // Move assignment operator
    MujocoModel& operator=(MujocoModel&& other) noexcept{
        // Check against self-assignment
        if(this == &other){
            return *this;
        }

        mj_deleteModel(model_);
        mj_deleteData(data_);

        model_ = other.model_;
        data_ = other.data_;
        position_offsets_ = other.position_offsets_;
        velocity_offsets_ = other.velocity_offsets_;

        other.model_ = nullptr;
        other.data_ = nullptr;

        return *this;
    }

    // Destructor
    ~MujocoModel(){
        mj_deleteModel(model_);
        mj_deleteData(data_);
    }

    void SyncSystemTo(const Base& model) override{
        Base::SyncSystemTo(model);
        for(size_t i = 0; i < Dimensions; ++i){
            *(data_->qpos + position_offsets_[i]) = static_cast<mjtNum>(Base::position_[i]);
            *(data_->qvel + velocity_offsets_[i]) = static_cast<mjtNum>(Base::velocity_[i]);
            *(data_->qacc + velocity_offsets_[i]) = static_cast<mjtNum>(Base::acceleration_[i]);
        }
    }

    bool Step(const VectorN& force_input, const VectorN& physical_position = VectorN::Constant(NAN)) override{
        Base::Step(force_input, physical_position);

        // Update the virtual position if a physical position is given
        const bool err = this->SyncVirtualPositionToPhysical(physical_position);

        // Zero the time-dependent states and do not step if the dynamics are paused
        if(this->DynamicsArePaused()){
            Base::velocity_.setZero();
            Base::acceleration_.setZero();
            for(size_t i = 0; i < Dimensions; ++i){
                *(data_->qvel + velocity_offsets_[i]) = 0.0;
                *(data_->qacc + velocity_offsets_[i]) = 0.0;
            }
            return err;
        }

        for(size_t i = 0; i < Dimensions; ++i){
            *(data_->qpos + position_offsets_[i]) = static_cast<mjtNum>(Base::position_[i]);
        }

        // Compute all intermediate results dependent on the state, but not the control
        // Note that by using mj_step1 and mj_step2, the integrator must be the default Euler
        mj_step1(model_, data_);

        // Update the state variables
        for(size_t i = 0; i < Dimensions; ++i){
            Base::position_[i] = static_cast<Scalar>(*(data_->qpos + position_offsets_[i]));
            Base::velocity_[i] = static_cast<Scalar>(*(data_->qvel + velocity_offsets_[i]));
        }
        const VectorN previous_velocity = Base::velocity_;

        // Apply the control
        MujocoVectorN::Map(data_->ctrl) = (force_input + this->EnforceSoftBound()).template cast<mjtNum>();

        // Finish computing results that depend on the control input
        mj_step2(model_, data_);

        // Update the state variables after the second step
        for(size_t i = 0; i < Dimensions; ++i){
            Base::position_[i] = static_cast<Scalar>(*(data_->qpos + position_offsets_[i]));
            Base::velocity_[i] = static_cast<Scalar>(*(data_->qvel + velocity_offsets_[i]));
        }

        // Restrict and set the position and velocity after the integration timestep
        this->EnforceHardBound();
        for(size_t i = 0; i < Dimensions; ++i){
            *(data_->qpos + position_offsets_[i]) = static_cast<mjtNum>(Base::position_[i]);
            *(data_->qvel + velocity_offsets_[i]) = static_cast<mjtNum>(Base::velocity_[i]);
        }

        // Update the acceleration with a backward difference
        Base::acceleration_ = (Base::velocity_ - previous_velocity) / model_->opt.timestep;

        return err;
    }

private:
    mjModel* model_;
    mjData* data_;

    std::array<size_t, Dimensions> position_offsets_;
    std::array<size_t, Dimensions> velocity_offsets_;
};

} // namespace gtfo